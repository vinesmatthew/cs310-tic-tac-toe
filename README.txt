Introduction
	This Tic-Tac-Toe application (with its classes stored in the git path "cs310-tic-tac-toe/src/main/java/edu/jsu/mcis/") is a theoretically universal, Java game where two players take turns marking squares, and the winner is determined by who can get the number of marked squares in a row equal to the size of the board. By default, the board size is three, meaning it is three squares long and wide. Changing the size is first done by running the file from a command terminal. Next, set the current directory to the file destination of TicTacToe.jar, and enter the command, “java -jar TicTacToe.jar,” where a number greater than or equal to three may be added to the end (e.g. “java -jar TicTacToe.jar 5”). If every square is marked with no winner detected, the game results in a tie.
	The program is comprised of five classes: TicTacToe, TicTacToeController, TicTacToeView, TicTacToeModel, and TicTacToeMove. TicTacToe without a suffix contains the main function that first accepts an argument and parses it to an integer if it contains data. That integer is then used to find the size of the board, which is used for calling the controller.

Main and Controller
	After retrieving the size of the board and initializing the model (TicTacToeModel) and view (TicTacToeView) of the program, the controller calls the “start()” function. A loop to test whether the game is over begins, and within that, the view’s “toString()” function displaying the board is executed. Retrieving the player’s next move, the “getNextMove()” function in the view takes the correct player’s turn taken into account by switching a boolean to true for player one (X) and false for player two (O). The move is then added the board, and if invalid, an input error is shown by the view (discussed later). After the operations for displaying the board, getting the player’s selection, and adding the selection to the board and model (also discussed later) are completed, they are repeated until the “isGameover” boolean is switched to true. To switch the boolean, a winner or tie must be decided, and then the board is shown with the results, whether it be “X!,” “O!,” or “TIE!,” above it.

View and Move
	Output and input for the program are handled in the view (aside from the original user input of board size). When the view is initialized, a scanner is assigned to a variable for assisting with further keyboard input. An if statement then outputs either “Player 1 (X) Move:” or “Player 1 (O) Move:” depending on which turn was last unless it is the first turn -- then player one begins. The instructions (“Enter the row and column numbers, separated by a space:”) are printed to the screen, and the next string input by the keyboard is recorded. When interpreting inputted strings, checking for errors in the format begin here as it first separates the two columns by splitting the string, using a space as the delimiter. With the two strings now in an array, each string in the array is checked to be sure the characters are integers and that there are the right number of strings in the array (two). If those tests are passed, the two strings are parsed into coordinates of the player’s selection and are further stored in the class, TicTacToeMove,” a class that stores coordinates (row and column number) for further use in the model class. The rest of the view is comprised of functions that print information. First, a function for printing errors may be called to print the message “Entered location is invalid, already marked, or out of bounds.” Next, another function may be called to display the winner of the game, but it requires the player’s name (“X” or ”O”) as its parameters. The last function prints the Tic Tac Toe board when called.

Model
 	There are many components to the model as it is the metaphorical brain of the program. Variables declared at the beginning of the model include the board size, the boolean to decide which player’s turn is next, and the board which is a two dimensional array of marks. A mark is essentially a variable matched to a string, but it is declared in a separate function which may be called to retrieve those strings. The specific strings in the function are “X,” “O,” and “-”. Using the same method, the results of the game after completion are stored -- those results being “X,” “O,” “TIE,” and “NONE”. In the constructor of the model, the size of the board is checked, then the boolean for deciding the players turn is switched to player one because of this being the first turn. Next, the two dimensional array of marks is declared using the size of the board to set the column and row length. Finally, a nested for loop populates each space in the array with empty (“-”) marks. 
	The “makeMark()” function is used for making a mark on the board by accepting a row and column number which acts as the X and Y in a graph; it also takes into account the player’s turn. The main code of the function actually lies in its further error checking. Along with the checking in the view, this further checks the selection by using the “isValidSquare()” and “isSquareMarked()” functions. When checking the validity of a player’s selection, it checks to make sure it is within the bounds of the board. The second function checks if the space being marked is empty or populated with another player’s mark. If the mark is within the bounds of the board and is not at the same location as another mark, the function marks the board with either “X” or “O” for player one and two respectively. Additionally, the “getMark()” function returns the mark requested in the parameters, the “isXTurn()” function returns a boolean indicating if player one or two is playing, and the “getWidth()” function returns the size of the board.
	To determine a winner, the “getResult()” function must be called by the “isGameover()” function (mentioned previously in the controller). In the “getResult()” function, the appropriate results (X, O, TIE, or NONE) are returned based on two other functions in the model named “isMarkWin()” and “isTie().” These functions contain the algorithm for setting win and tie conditions. Using nested if loops inside nested for loops, each square is checked left to right, then up to down. When the row and column numbers are equal as many times in a row as the board size, a right-diagonal win condition is met. When the row and column numbers added to each other equal one subtracted by the board size as many times as the board size in a row, a left-diagonal win condition is met. Along with testing for diagonals, the horizontal and vertical counters are set. If there are any same row numbers or column numbers, a counter is added to either the vertical or horizontal variables. If, at any point, the number of identical row numbers and column numbers equal the size of the board, a vertical or horizontal win condition is met. For the “isTie()” function, the board is iterated through, and if there are no empty spaces, and there are no winners, a true is returned to indicate a tie. 
	Constructing the board takes place in the “toString()” method of the model (which is called by the view to display the board). StringBuilders are the primary component of construction as the correct strings are appended in an efficient manner. First, the column headers are appended with the help of a for loop. Next, after adding a new line, a nested for loop iterates through the board and appends each row at a time from left to right by adding the row number, row marks, then a new line. Additionally, a new line is also added right before the string is returned.

Example Output

	Player 1 (X) Move:
	Enter the row and column numbers, separated by a space: 1 1


	  012
	0 -X-
	1 -XO
	2 ---

	Player 2 (O) Move:
	Enter the row and column numbers, separated by a space: -1 2
	Entered location is invalid, already marked, or out of bounds.


	  012
	0 -X-
	1 -XO
	2 ---

	Player 2 (O) Move:
	Enter the row and column numbers, separated by a space:
	
Graphical Possibilities
	With only edits to the view and associated calls from the controller, this program may be made into a graphical program. By extending the view to a JFrame with the appropriate algorithms to convert the model to graphical objects, a window with any size board can be filled with buttons.
	To start, a two-dimensional array of JButtons must be created for the board, and they are then populated with an imbedded for-loop that adds each JButton to a JPanel. To keep track of the coordinates, the button's names are set to include their coordinates. With the JPanel added to the JFrame, a label is also added to the frame to greet the players and announce a winner. Now that the board is created, there must be functions to change the board. The first is "setButton()". When a player clicks a button, it is sent to this function, disabling the button and setting the text to either "X" or "O" respectively. Similarly, when the game is marked as over, the "setWinner()" function sets the label as "X" "O" or "TIE" respetively.
	Changes to the controller include an action performed function that collects information from a button when it is clicked. It first sets the button in the view, then sets a winner if one is found. The rest of the controller consists of the function that creates the JFrame from the view class.
